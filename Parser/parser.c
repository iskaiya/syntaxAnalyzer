#include "parser.h"

Token* peek(Parser* p);
void advance(Parser* p);
bool check_token(Parser* p, const char* type);

// Add these to parser.c (after your includes and before other functions)

#define MAX_TRANSITIONS 1000
#define MAX_STACK_DEPTH 100

typedef struct {
    int step;
    char stack[256];
    char input_symbol[64];
    char action[128];
    char production[256];
} Transition;

// Global tracking variables
Transition transitions[MAX_TRANSITIONS];
int transition_count = 0;
int current_depth = 0;
char stack_trace[MAX_STACK_DEPTH][64];

// Initialize transition tracking
void init_transition_tracking() {
    transition_count = 0;
    current_depth = 0;
    memset(stack_trace, 0, sizeof(stack_trace));
    strcpy(stack_trace[0], "$");
    current_depth = 1;
}

// Add a transition record
void record_transition(const char* input_sym, const char* action, const char* production) {
    if (transition_count >= MAX_TRANSITIONS) return;
    
    Transition* t = &transitions[transition_count++];
    t->step = transition_count;
    
    // Build stack string from bottom to top
    strcpy(t->stack, "$");
    for (int i = 1; i < current_depth; i++) {
        strcat(t->stack, " ");
        strcat(t->stack, stack_trace[i]);
    }
    
    strncpy(t->input_symbol, input_sym, 63);
    strncpy(t->action, action, 127);
    strncpy(t->production, production ? production : "", 255);
}

// Push non-terminal onto stack trace
void push_stack(const char* symbol) {
    if (current_depth < MAX_STACK_DEPTH) {
        strncpy(stack_trace[current_depth++], symbol, 63);
    }
}

// Pop from stack trace
void pop_stack() {
    if (current_depth > 1) {
        current_depth--;
    }
}

void enter_nonterminal(const char* nonterminal, const char* lookahead) {
    char action[128];
    sprintf(action, "ENTER %s", nonterminal);
    push_stack(nonterminal);
    record_transition(lookahead, action, NULL);
}

void exit_nonterminal(const char* nonterminal, const char* lookahead) {
    char action[128];
    sprintf(action, "EXIT %s", nonterminal);
    record_transition(lookahead, action, NULL);
    pop_stack();
}

void match_terminal(const char* terminal, const char* value) {
    char action[128];
    sprintf(action, "MATCH '%s'", terminal);
    char input[64];
    sprintf(input, "%s", value);
    record_transition(input, action, NULL);
}

void apply_production(const char* production_rule) {
    record_transition("", "REDUCE", production_rule);
}

// Write transition table to file
void write_transition_table(const char* filename) {
    printf("DEBUG: Attempting to write transition table to '%s'\n", filename);
    printf("DEBUG: transition_count = %d\n", transition_count);
    
    FILE* fp = fopen(filename, "w");
    if (!fp) {
        printf("ERROR: Cannot create transition table file '%s'\n", filename);
        return;
    }
    
    fprintf(fp, "PARSING TRANSITION TABLE\n");
    fprintf(fp, "Generated by Recursive Descent Parser (Pushdown Automaton)\n");
    fprintf(fp, "======================================================================\n\n");
    
    // Table header
    fprintf(fp, "%-6s %-30s %-20s %-25s %-30s\n", 
            "STEP", "STACK", "INPUT", "ACTION", "PRODUCTION/DETAILS");
    fprintf(fp, "%-6s %-30s %-20s %-25s %-30s\n",
            "------", "------------------------------", 
            "--------------------", "-------------------------",
            "------------------------------");
    
    // Table rows
    for (int i = 0; i < transition_count; i++) {
        Transition* t = &transitions[i];
        fprintf(fp, "%-6d %-30s %-20s %-25s %-30s\n",
                t->step,
                t->stack,
                t->input_symbol,
                t->action,
                t->production);
    }
    
    fprintf(fp, "\n======================================================================\n");
    fprintf(fp, "Total transitions: %d\n", transition_count);
    fprintf(fp, "End of Transition Table\n");
    
    fclose(fp);
    printf("Transition table written to '%s'\n", filename);
}

// Alternative: ASCII Diagram format
void write_transition_diagram(const char* filename) {
    printf("DEBUG: Attempting to write transition table to '%s'\n", filename);
    printf("DEBUG: transition_count = %d\n", transition_count);
    
    FILE* fp = fopen(filename, "w");
    if (!fp) {
        printf("ERROR: Cannot create transition table file '%s'\n", filename);
        return;
    }
    
    fprintf(fp, "PARSING TRANSITION DIAGRAM\n");
    fprintf(fp, "======================================================================\n\n");
    
    for (int i = 0; i < transition_count; i++) {
        Transition* t = &transitions[i];
        
        fprintf(fp, "[Step %d]\n", t->step);
        fprintf(fp, "  Stack:  %s\n", t->stack);
        fprintf(fp, "  Input:  %s\n", t->input_symbol);
        fprintf(fp, "  Action: %s\n", t->action);
        if (strlen(t->production) > 0) {
            fprintf(fp, "  Rule:   %s\n", t->production);
        }
        fprintf(fp, "  ↓\n");
    }
    
    fprintf(fp, "\n[ACCEPT]\n");
    fprintf(fp, "\n======================================================================\n");
    fprintf(fp, "End of Transition Diagram\n");
    
    fclose(fp);
    printf("Transition diagram written to '%s'\n", filename);
}

void write_transition_summary(const char* filename) {
    FILE* fp = fopen(filename, "w");
    if (!fp) {
        printf("ERROR: Cannot create transition summary file '%s'\n", filename);
        return;
    }
    
    fprintf(fp, "PARSING TRANSITION SUMMARY\n");
    fprintf(fp, "======================================================================\n\n");
    
    int depth = 0;
    char last_action[128] = "";
    
    for (int i = 0; i < transition_count; i++) {
        Transition* t = &transitions[i];
        
        // Only show ENTER and EXIT (skip individual MATCH actions)
        if (strncmp(t->action, "ENTER", 5) == 0) {
            depth++;
            for (int j = 0; j < depth - 1; j++) fprintf(fp, "  ");
            fprintf(fp, "↓ %s [Input: %s]\n", t->action, t->input_symbol);
        } else if (strncmp(t->action, "EXIT", 4) == 0) {
            for (int j = 0; j < depth - 1; j++) fprintf(fp, "  ");
            fprintf(fp, "↑ %s\n", t->action);
            depth--;
        }
        // Skip MATCH actions for summary view
    }
    
    fprintf(fp, "\n======================================================================\n");
    fprintf(fp, "Total parsing steps: %d\n", transition_count);
    fprintf(fp, "End of Summary\n");
    
    fclose(fp);
    printf("Transition summary written to '%s'\n", filename);
}

// ============ UTILITY FUNCTIONS ============

// Trim whitespace from string
void trim(char* str) {
    char* start = str;
    char* end;
    
    // Trim leading space
    while(isspace((unsigned char)*start)) start++;
    
    if(*start == 0) {
        str[0] = '\0';
        return;
    }
    
    // Trim trailing space
    end = start + strlen(start) - 1;
    while(end > start && isspace((unsigned char)*end)) end--;
    
    // Write new null terminator
    size_t len = (end - start) + 1;
    memmove(str, start, len);
    str[len] = '\0';
}

// Create a new parse tree node
ParseTreeNode* create_node(const char* name, const char* value) {
    ParseTreeNode* node = (ParseTreeNode*)malloc(sizeof(ParseTreeNode));
    strcpy(node->name, name);
    if (value) {
        strcpy(node->value, value);
    } else {
        node->value[0] = '\0';
    }
    node->child_count = 0;
    return node;
}

// Add child to parse tree node
void add_child(ParseTreeNode* parent, ParseTreeNode* child) {
    if (child != NULL && parent->child_count < MAX_CHILDREN) {
        parent->children[parent->child_count++] = child;
    }
}

// Free parse tree memory
void free_tree(ParseTreeNode* node) {
    if (node == NULL) return;
    for (int i = 0; i < node->child_count; i++) {
        free_tree(node->children[i]);
    }
    free(node);
}

// ============ PARSER CORE FUNCTIONS ============

// Create parser
Parser* create_parser(Token* tokens, int count) {
    Parser* p = (Parser*)malloc(sizeof(Parser));
    p->tokens = tokens;
    p->token_count = count;
    p->pos = 0;
    p->current_token = (count > 0) ? &tokens[0] : NULL;
    p->error_count = 0;
    p->parse_tree = NULL;
    return p;
}

// Free parser memory
void free_parser(Parser* p) {
    if (p->parse_tree) {
        free_tree(p->parse_tree);
    }
    if (p->tokens) {
        free(p->tokens);
    }
    free(p);
}

// Record error
void parser_error(Parser* p, const char* message) {
    if (p->error_count < MAX_ERRORS) {
        if (p->current_token) {
            sprintf(p->errors[p->error_count], 
                    "Line %d: %s (Found: %s '%s')",
                    p->current_token->line, message,
                    p->current_token->type, p->current_token->lexeme);
        } else {
            sprintf(p->errors[p->error_count], "End of file: %s", message);
        }
        printf("ERROR: %s\n", p->errors[p->error_count]);
        p->error_count++;
    }
}

// ERROR RECOVERY: Skip tokens until we find a synchronizing token
void synchronize(Parser* p, const char* sync_tokens[], int sync_count) {
    printf("    [ERROR RECOVERY] Synchronizing...\n");
    
    int tokens_skipped = 0;
    while (peek(p) && tokens_skipped < 50) {  // Prevent infinite loops
        // Check if current token is a sync token
        for (int i = 0; i < sync_count; i++) {
            if (check_token(p, sync_tokens[i])) {
                printf("    [ERROR RECOVERY] Synchronized at %s\n", sync_tokens[i]);
                return;
            }
        }
        // Also stop at statement terminators and block delimiters
        if (check_token(p, "D_SEMICOLON")) {
            printf("    [ERROR RECOVERY] Synchronized at semicolon\n");
            return;
        }
        if (check_token(p, "D_RBRACE")) {
            printf("    [ERROR RECOVERY] Synchronized at closing brace\n");
            return;
        }
        if (check_token(p, "D_LBRACE")) {
            printf("    [ERROR RECOVERY] Synchronized at opening brace\n");
            return;
        }
        // Stop at statement starters
        if (check_token(p, "R_BILANG") || check_token(p, "R_LUTANG") ||
            check_token(p, "R_BULYAN") || check_token(p, "R_KWERDAS") ||
            check_token(p, "K_KUNG") || check_token(p, "K_PARA") ||
            check_token(p, "K_HABANG") || check_token(p, "K_GAWIN") ||
            check_token(p, "K_ANI") || check_token(p, "K_TANIM")) {
            printf("    [ERROR RECOVERY] Synchronized at statement keyword\n");
            return;
        }
        
        advance(p);
        tokens_skipped++;
    }
    printf("    [ERROR RECOVERY] Reached synchronization limit\n");
}

// ERROR RECOVERY: Skip to end of statement (semicolon or closing brace)
void skip_to_statement_end(Parser* p) {
    printf("    [ERROR RECOVERY] Skipping to statement end...\n");
    int tokens_skipped = 0;
    while (peek(p) && tokens_skipped < 50) {
        if (check_token(p, "D_SEMICOLON")) {
            advance(p); // consume the semicolon
            printf("    [ERROR RECOVERY] Found semicolon\n");
            return;
        }
        if (check_token(p, "D_RBRACE")) {
            printf("    [ERROR RECOVERY] Found closing brace (stopping before it)\n");
            return;
        }
        // Also stop at next statement starter
        if (check_token(p, "R_BILANG") || check_token(p, "R_LUTANG") ||
            check_token(p, "R_BULYAN") || check_token(p, "R_KWERDAS") ||
            check_token(p, "K_KUNG") || check_token(p, "K_PARA") ||
            check_token(p, "K_HABANG") || check_token(p, "K_GAWIN") ||
            check_token(p, "K_ANI") || check_token(p, "K_TANIM") ||
            check_token(p, "D_LBRACE")) {
            printf("    [ERROR RECOVERY] Found next statement\n");
            return;
        }
        advance(p);
        tokens_skipped++;
    }
}

// ERROR RECOVERY: Skip to matching closing brace
void skip_to_closing_brace(Parser* p) {
    printf("    [ERROR RECOVERY] Skipping to closing brace...\n");
    int brace_count = 1;
    int tokens_skipped = 0;
    while (peek(p) && brace_count > 0 && tokens_skipped < 100) {
        if (check_token(p, "D_LBRACE")) {
            brace_count++;
        } else if (check_token(p, "D_RBRACE")) {
            brace_count--;
            if (brace_count == 0) {
                printf("    [ERROR RECOVERY] Found matching closing brace\n");
                return;
            }
        }
        advance(p);
        tokens_skipped++;
    }
    printf("    [ERROR RECOVERY] Brace matching ended\n");
}

// Advance to next token (PDA: POP operation)
void advance(Parser* p) {
    p->pos++;
    if (p->pos < p->token_count) {
        p->current_token = &p->tokens[p->pos];
    } else {
        p->current_token = NULL;
    }
}

// Match token type with ERROR RECOVERY
ParseTreeNode* match(Parser* p, const char* expected_type) {
    if (check_token(p, expected_type)) {
        // Track the terminal BEFORE advancing
        match_terminal(expected_type, p->current_token->lexeme);
        
        ParseTreeNode* node = create_node(p->current_token->type, p->current_token->lexeme);
        advance(p);
        return node;
    }
    
    // Handle error...
    char error_msg[256];
    sprintf(error_msg, "Expected %s but found %s", expected_type, p->current_token->type);
    parser_error(p, error_msg);
    return create_node("ERROR", "");
}

// Peek at current token
Token* peek(Parser* p) {
    return p->current_token;
}

// Check if current token matches type
bool check_token(Parser* p, const char* type) {
    return (p->current_token && strcmp(p->current_token->type, type) == 0);
}

// Forward declarations of all parsing functions (PDA states)
ParseTreeNode* parse_main_function(Parser* p);
ParseTreeNode* parse_return_type(Parser* p);
ParseTreeNode* parse_parameter_list(Parser* p);
ParseTreeNode* parse_function_body(Parser* p);
ParseTreeNode* parse_statement_list(Parser* p);
ParseTreeNode* parse_statement(Parser* p);
ParseTreeNode* parse_declaration(Parser* p);
ParseTreeNode* parse_data_type(Parser* p);
ParseTreeNode* parse_identifier_list(Parser* p);
ParseTreeNode* parse_identifier_tail(Parser* p);
ParseTreeNode* parse_assignment(Parser* p);
ParseTreeNode* parse_expression(Parser* p);
ParseTreeNode* parse_expression_tail(Parser* p);
ParseTreeNode* parse_term(Parser* p);
ParseTreeNode* parse_term_tail(Parser* p);
ParseTreeNode* parse_factor(Parser* p);
ParseTreeNode* parse_conditional(Parser* p);
ParseTreeNode* parse_conditional_tail(Parser* p);
ParseTreeNode* parse_boolean_expression(Parser* p);
ParseTreeNode* parse_relop(Parser* p);
ParseTreeNode* parse_iterative(Parser* p);
ParseTreeNode* parse_for_loop(Parser* p);
ParseTreeNode* parse_while_loop(Parser* p);
ParseTreeNode* parse_do_while_loop(Parser* p);
ParseTreeNode* parse_print(Parser* p);
ParseTreeNode* parse_print_args(Parser* p);
ParseTreeNode* parse_scan(Parser* p);
ParseTreeNode* parse_scan_args(Parser* p);
ParseTreeNode* parse_class_definition(Parser* p);

// ============ HELPERS ============
// Helper to match with better error recovery
ParseTreeNode* match_with_recovery(Parser* p, const char* expected, const char* error_msg) {
    if (peek(p) && check_token(p, expected)) {
        return match(p, expected);
    }
    
    parser_error(p, error_msg);
    const char* sync[] = {expected};
    synchronize(p, sync, 1);
    
    if (peek(p) && check_token(p, expected)) {
        return match(p, expected);
    }
    
    char error_name[64];
    sprintf(error_name, "missing_%s", expected);
    return create_node("ERROR", error_name);
}

// Helper for delimiters (parentheses, braces)
ParseTreeNode* match_delimiter(Parser* p, const char* delim, const char* error_msg, const char* sync_alt) {
    if (peek(p) && check_token(p, delim)) {
        return match(p, delim);
    }
    
    parser_error(p, error_msg);
    const char* sync[] = {delim, sync_alt};
    synchronize(p, sync, sync_alt ? 2 : 1);
    
    if (peek(p) && check_token(p, delim)) {
        return match(p, delim);
    }
    
    return create_node("ERROR", "missing_delimiter");
}

// Helper for checking multiple token types
bool check_any(Parser* p, const char* types[], int count) {
    for (int i = 0; i < count; i++) {
        if (check_token(p, types[i])) return true;
    }
    return false;
}


// ============ PROGRAM STRUCTURE ============

bool parse_program(Parser* p) {
    printf("\n=== Starting Syntax Analysis (PDA) ===\n");
    printf("Parsing Program...\n");
    ParseTreeNode* node = create_node("Program", NULL);
    
    if (peek(p) && (check_token(p, "R_BILANG") || check_token(p, "R_VOID") || 
                     check_token(p, "R_WALA"))) {
        add_child(node, parse_main_function(p));
    } else if (peek(p) && check_token(p, "K_PANGKAT")) {
        while (peek(p) && check_token(p, "K_PANGKAT")) {
            add_child(node, parse_class_definition(p));
        }
    } else {
        parser_error(p, "Expected main function or class definition");
        // ERROR RECOVERY: Try to find start of a valid construct
        const char* sync[] = {"R_BILANG", "R_VOID", "R_WALA", "K_PANGKAT"};
        synchronize(p, sync, 4);
        if (peek(p)) {
            // Try parsing again after recovery
            if (check_token(p, "R_BILANG") || check_token(p, "R_VOID") || 
                check_token(p, "R_WALA")) {
                add_child(node, parse_main_function(p));
            } else if (check_token(p, "K_PANGKAT")) {
                add_child(node, parse_class_definition(p));
            }
        }
    }
    
    p->parse_tree = node;
    printf("DEBUG: Set parse tree\n");
    printf("Program parsing complete!\n");
    printf("Total errors found: %d\n", p->error_count);
    printf("DEBUG: About to return from parse_program\n");
    return (p->error_count == 0);
}

ParseTreeNode* parse_main_function(Parser* p) {
    enter_nonterminal("MainFunction", p->current_token->lexeme);
    printf("  [PDA PUSH] Parsing Main Function...\n");
    ParseTreeNode* node = create_node("MainFunction", NULL);
    
    add_child(node, parse_return_type(p));
    add_child(node, match(p, "R_UGAT"));
    add_child(node, match(p, "D_LPAREN"));
    add_child(node, parse_parameter_list(p));
    add_child(node, match(p, "D_RPAREN"));
    
    // ERROR RECOVERY: Ensure we have opening brace for function body
    if (peek(p) && !check_token(p, "D_LBRACE")) {
        parser_error(p, "Expected '{' to start function body");
        const char* sync[] = {"D_LBRACE"};
        synchronize(p, sync, 1);
    }
    
    add_child(node, parse_function_body(p));
    printf("  [PDA POP] Main Function complete\n");
    
    // SAFETY CHECK: Make sure we have a valid token before accessing it
    if (p->current_token && p->current_token->lexeme) {
        exit_nonterminal("MainFunction", p->current_token->lexeme);
    } else {
        exit_nonterminal("MainFunction", "EOF");
    }
    
    printf("DEBUG: About to return from parse_main_function\n");
    return node;
}

ParseTreeNode* parse_return_type(Parser* p) {
    enter_nonterminal("ReturnType", p->current_token->lexeme);

    ParseTreeNode* node = create_node("ReturnType", NULL);
    if (peek(p) && (check_token(p, "R_BILANG") || check_token(p, "R_VOID") || 
                     check_token(p, "R_WALA"))) {
        const char* lexeme = p->current_token->lexeme;
        add_child(node, create_node(p->current_token->type, p->current_token->lexeme));
        advance(p);
    } else {
        parser_error(p, "Expected return type (R_BILANG, R_VOID, or R_WALA)");
    }

    exit_nonterminal("ReturnType", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_parameter_list(Parser* p) {
    enter_nonterminal("ParameterList", p->current_token->lexeme);
    ParseTreeNode* node = create_node("ParameterList", NULL);

    if (peek(p) && check_token(p, "R_KWERDAS")) {
        add_child(node, match(p, "R_KWERDAS"));
        add_child(node, match(p, "D_LBRACKET"));
        add_child(node, match(p, "D_RBRACKET"));
        add_child(node, match(p, "L_IDENTIFIER"));

    } else {
        add_child(node, create_node("ε", "empty"));
    }

    exit_nonterminal("ParameterList", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_function_body(Parser* p) {
    enter_nonterminal("FunctionBody", p->current_token->lexeme);
    ParseTreeNode* node = create_node("FunctionBody", NULL);

    add_child(node, match(p, "D_LBRACE"));
    add_child(node, parse_statement_list(p));
    add_child(node, match(p, "D_RBRACE"));

    exit_nonterminal("FunctionBody", p->current_token->lexeme);
    return node;
}

// ============ STATEMENTS ============

ParseTreeNode* parse_statement_list(Parser* p) {
    enter_nonterminal("StatementList", p->current_token->lexeme);
    ParseTreeNode* node = create_node("StatementList", NULL);
    
    if (peek(p) && (check_token(p, "R_BILANG") || check_token(p, "R_LUTANG") ||
                     check_token(p, "R_BULYAN") || check_token(p, "R_KWERDAS") ||
                     check_token(p, "L_IDENTIFIER") || check_token(p, "K_KUNG") ||
                     check_token(p, "K_PARA") || check_token(p, "K_HABANG") ||
                     check_token(p, "K_GAWIN") || check_token(p, "K_ANI") ||
                     check_token(p, "K_TANIM"))) {
        add_child(node, parse_statement(p));
        add_child(node, parse_statement_list(p));
    } else {
        add_child(node, create_node("ε", "empty"));
    }
    exit_nonterminal("StatementList", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_statement(Parser* p) {
    enter_nonterminal("Statement", p->current_token->lexeme);
    ParseTreeNode* node = create_node("Statement", NULL);
    
    // ERROR RECOVERY: Check if we have a valid statement starter
    if (!peek(p)) {
        parser_error(p, "Unexpected end of file in statement");
        return node;
    }
    
    if (check_token(p, "R_BILANG") || check_token(p, "R_LUTANG") ||
        check_token(p, "R_BULYAN") || check_token(p, "R_KWERDAS")) {
        add_child(node, parse_declaration(p));
    } else if (check_token(p, "L_IDENTIFIER")) {
        add_child(node, parse_assignment(p));
    } else if (check_token(p, "K_KUNG")) {
        add_child(node, parse_conditional(p));
    } else if (check_token(p, "K_PARA") || check_token(p, "K_HABANG") || 
               check_token(p, "K_GAWIN")) {
        add_child(node, parse_iterative(p));
    } else if (check_token(p, "K_ANI")) {
        add_child(node, parse_print(p));
    } else if (check_token(p, "K_TANIM")) {
        add_child(node, parse_scan(p));
    } else {
        parser_error(p, "Invalid statement - expected declaration, assignment, or control structure");
        // ERROR RECOVERY: Skip to end of statement
        skip_to_statement_end(p);
        add_child(node, create_node("ERROR", "invalid_statement"));
    }
    exit_nonterminal("Statement", p->current_token->lexeme);
    return node;
}

// ============ DECLARATION ============

ParseTreeNode* parse_declaration(Parser* p) {
    enter_nonterminal("Declaration", p->current_token->lexeme);
    printf("    [PDA PUSH] Parsing Declaration...\n");
    ParseTreeNode* node = create_node("Declaration", NULL);

    int declaration_start_line = p->current_token ? p->current_token->line : 0;

    add_child(node, parse_data_type(p));
    add_child(node, parse_identifier_list(p));
    
    // ERROR RECOVERY: Check for semicolon
    if (peek(p) && !check_token(p, "D_SEMICOLON")) {
        char msg[256];
        sprintf(msg, "Missing semicolon at end of declaration (started on line %d)", 
                declaration_start_line);
        parser_error(p, msg);        
        
        // Look for semicolon or next statement
        const char* sync[] = {"D_SEMICOLON", "R_BILANG", "R_LUTANG", "R_BULYAN", 
                               "R_KWERDAS", "L_IDENTIFIER", "K_KUNG", "K_PARA", 
                               "K_HABANG", "K_GAWIN", "K_ANI", "K_TANIM", "D_RBRACE"};
        synchronize(p, sync, 13);
        
        // If we found a semicolon, consume it
        if (peek(p) && check_token(p, "D_SEMICOLON")) {
            add_child(node, match(p, "D_SEMICOLON"));
        } else {
            // No semicolon found, add error node and continue
            add_child(node, create_node("ERROR", "missing_semicolon"));
        }
    } else {
        add_child(node, match(p, "D_SEMICOLON"));
    }

    printf("    [PDA POP] Declaration complete\n");
    exit_nonterminal("Declaration", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_data_type(Parser* p) {
    enter_nonterminal("DataType", p->current_token->lexeme);
    ParseTreeNode* node = create_node("DataType", NULL);
    if (peek(p) && (check_token(p, "R_BILANG") || check_token(p, "R_LUTANG") ||
                     check_token(p, "R_BULYAN") || check_token(p, "R_KWERDAS"))) {
        add_child(node, create_node(p->current_token->type, p->current_token->lexeme));
        advance(p);
    } else {
        parser_error(p, "Expected data type (R_BILANG, R_LUTANG, R_BULYAN, or R_KWERDAS)");
        // ERROR RECOVERY: Create error node and try to continue
        add_child(node, create_node("ERROR", "missing_datatype"));
    }
    exit_nonterminal("DataType", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_identifier_list(Parser* p) {
    enter_nonterminal("IdentifierList", p->current_token->lexeme);
    ParseTreeNode* node = create_node("IdentifierList", NULL);
    add_child(node, match(p, "L_IDENTIFIER"));
    
    // Check for optional initialization: = <Expression>
    if (peek(p) && check_token(p, "O_ASSIGN")) {
        add_child(node, match(p, "O_ASSIGN"));
        add_child(node, parse_expression(p));
    }
    
    add_child(node, parse_identifier_tail(p));
    exit_nonterminal("IdentifierList", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_identifier_tail(Parser* p) {
    enter_nonterminal("IdentifierTail", p->current_token->lexeme);
    ParseTreeNode* node = create_node("IdentifierTail", NULL);
    
    if (peek(p) && check_token(p, "D_COMMA")) {
        add_child(node, match(p, "D_COMMA"));
        add_child(node, match(p, "L_IDENTIFIER"));
        
        // Check for optional initialization for this identifier
        if (peek(p) && check_token(p, "O_ASSIGN")) {
            add_child(node, match(p, "O_ASSIGN"));
            add_child(node, parse_expression(p));
        }
        
        add_child(node, parse_identifier_tail(p));
    } 
    // ERROR RECOVERY: Check if there's an identifier without comma (missing comma error)
    else if (peek(p) && check_token(p, "L_IDENTIFIER")) {
        parser_error(p, "Missing comma between identifiers in declaration");
        add_child(node, create_node("ERROR", "missing_comma"));
        add_child(node, match(p, "L_IDENTIFIER"));
        
        // Check for optional initialization
        if (peek(p) && check_token(p, "O_ASSIGN")) {
            add_child(node, match(p, "O_ASSIGN"));
            add_child(node, parse_expression(p));
        }
        
        add_child(node, parse_identifier_tail(p));
    }
    else {
        add_child(node, create_node("ε", "empty"));
    }
    exit_nonterminal("IdentifierTail", p->current_token->lexeme);
    return node;
}

// ============ ASSIGNMENT AND EXPRESSIONS ============

ParseTreeNode* parse_assignment(Parser* p) {
    enter_nonterminal("Assignment", p->current_token->lexeme);
    printf("    [PDA PUSH] Parsing Assignment...\n");
    ParseTreeNode* node = create_node("Assignment", NULL);
    
    int assign_start_line = p->current_token ? p->current_token->line : 0;
    
    add_child(node, match(p, "L_IDENTIFIER"));
    
    if (peek(p) && !check_token(p, "O_ASSIGN")) {
        parser_error(p, "Expected '=' in assignment");
        const char* sync[] = {"O_ASSIGN"};
        synchronize(p, sync, 1);
    }
    
    add_child(node, match(p, "O_ASSIGN"));
    
    // Parse expression - this will handle the parenthesis checking
    add_child(node, parse_expression(p));
    
    // Check for semicolon
    if (peek(p) && !check_token(p, "D_SEMICOLON")) {
        char msg[256];
        sprintf(msg, "Missing semicolon at end of assignment (line %d)", assign_start_line);
        parser_error(p, msg);
        
        const char* sync[] = {"D_SEMICOLON"};
        synchronize(p, sync, 1);
        
        if (peek(p) && check_token(p, "D_SEMICOLON")) {
            add_child(node, match(p, "D_SEMICOLON"));
        } else {
            add_child(node, create_node("ERROR", "missing_semicolon"));
        }
    } else {
        add_child(node, match(p, "D_SEMICOLON"));
    }
    
    printf("    [PDA POP] Assignment complete\n");
    exit_nonterminal("Assignment", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_expression(Parser* p) {
    enter_nonterminal("Expression", p->current_token->lexeme);
    ParseTreeNode* node = create_node("Expression", NULL);
    add_child(node, parse_term(p));
    add_child(node, parse_expression_tail(p));
    exit_nonterminal("Expression", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_expression_tail(Parser* p) {
    enter_nonterminal("ExpressionTail", p->current_token->lexeme);
    ParseTreeNode* node = create_node("ExpressionTail", NULL);
    
    if (peek(p) && (check_token(p, "O_PLUS") || check_token(p, "O_MINUS"))) {
        add_child(node, create_node(p->current_token->type, p->current_token->lexeme));
        advance(p);
        add_child(node, parse_term(p));
        add_child(node, parse_expression_tail(p));
    } 
    // Check if we hit a semicolon while still in expression (unmatched parenthesis)
    else if (peek(p) && check_token(p, "D_SEMICOLON")) {
        // This is normal - expression ends
        add_child(node, create_node("ε", "empty"));
    }
    else {
        add_child(node, create_node("ε", "empty"));
    }
    exit_nonterminal("ExpressionTail", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_term(Parser* p) {
    enter_nonterminal("Term", p->current_token->lexeme);
    ParseTreeNode* node = create_node("Term", NULL);
    add_child(node, parse_factor(p));
    add_child(node, parse_term_tail(p));
    exit_nonterminal("Term", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_term_tail(Parser* p) {
    enter_nonterminal("TermTail", p->current_token->lexeme);
    ParseTreeNode* node = create_node("TermTail", NULL);
    if (peek(p) && (check_token(p, "O_MULTIPLY") || check_token(p, "O_DIVIDE"))) {
        add_child(node, create_node(p->current_token->type, p->current_token->lexeme));
        advance(p);
        add_child(node, parse_factor(p));
        add_child(node, parse_term_tail(p));
    } else {
        add_child(node, create_node("ε", "empty"));
    }
    exit_nonterminal("TermTail", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_factor(Parser* p) {
    enter_nonterminal("Factor", p->current_token->lexeme);
    ParseTreeNode* node = create_node("Factor", NULL);
    
    if (peek(p) && check_token(p, "L_IDENTIFIER")) {
        add_child(node, match(p, "L_IDENTIFIER"));
    } 
    else if (peek(p) && check_token(p, "L_BILANG_LITERAL")) {
        add_child(node, match(p, "L_BILANG_LITERAL"));
    } 
    else if (peek(p) && check_token(p, "L_LUTANG_LITERAL")) {
        add_child(node, match(p, "L_LUTANG_LITERAL"));
    }
    else if (peek(p) && check_token(p, "L_KWERDAS_LITERAL")) {
        add_child(node, match(p, "L_KWERDAS_LITERAL"));
    }
    else if (peek(p) && (check_token(p, "R_TAMA") || check_token(p, "R_MALI"))) {
        add_child(node, create_node(p->current_token->type, p->current_token->lexeme));
        advance(p);
    }
    else if (peek(p) && (check_token(p, "R_PI") || check_token(p, "R_E_NUM"),
                        check_token(p, "R_Kiss") || check_token(p, "R_SAMPLE_CONST_STRING"))) {
        add_child(node,  create_node(p->current_token->type, p->current_token->lexeme));
    }
    else if (peek(p) && check_token(p, "D_LPAREN")) {
        int paren_line = p->current_token->line;
        add_child(node, match(p, "D_LPAREN"));
        add_child(node, parse_expression(p));
        
        // ERROR RECOVERY: Check for closing parenthesis
        if (peek(p) && !check_token(p, "D_RPAREN")) {
            char msg[256];
            sprintf(msg, "Missing closing parenthesis ')' for '(' on line %d", paren_line);
            parser_error(p, msg);
            
            // Look for closing paren or semicolon
            const char* sync[] = {"D_RPAREN", "D_SEMICOLON"};
            synchronize(p, sync, 2);
            
            if (peek(p) && check_token(p, "D_RPAREN")) {
                add_child(node, match(p, "D_RPAREN"));
            } else {
                add_child(node, create_node("ERROR", "missing_rparen"));
                printf("    [ERROR RECOVERY] Could not find closing paren, continuing...\n");
            }
        } else {
            add_child(node, match(p, "D_RPAREN"));
        }
    } 
    else if (peek(p) && (check_token(p, "O_PLUS") || check_token(p, "O_MINUS") ||
                          check_token(p, "O_MULTIPLY") || check_token(p, "O_DIVIDE"))) {
        parser_error(p, "Unexpected operator in expression (possible double operator)");
        add_child(node, create_node("ERROR", "unexpected_operator"));
        advance(p);
        
        if (peek(p) && !check_token(p, "D_SEMICOLON") && !check_token(p, "D_RPAREN")) {
            return parse_factor(p);
        }
    }
    else {
        parser_error(p, "Expected identifier, literal, constant, or '(' in expression");
        add_child(node, create_node("ERROR", "invalid_factor"));
        if (peek(p) && !check_token(p, "D_SEMICOLON") && !check_token(p, "D_RPAREN")) {
            advance(p);
        }
    }
    exit_nonterminal("Factor", p->current_token->lexeme);
    return node;
}

// ============ CONDITIONALS ============

ParseTreeNode* parse_conditional(Parser* p) {
    enter_nonterminal("Conditional", p->current_token->lexeme);
    printf("    [PDA PUSH] Parsing Conditional...\n");
    ParseTreeNode* node = create_node("Conditional", NULL);
    add_child(node, match(p, "K_KUNG"));
    add_child(node, match(p, "D_LPAREN"));
    add_child(node, parse_boolean_expression(p));
    
    // ERROR RECOVERY: Check for closing parenthesis
    if (peek(p) && !check_token(p, "D_RPAREN")) {
        parser_error(p, "Missing ')' after condition");
        const char* sync[] = {"D_RPAREN", "D_LBRACE"};
        synchronize(p, sync, 2);

        if (peek(p) && check_token(p, "D_RPAREN")) {
            add_child(node, match(p, "D_RPAREN"));
        } else {
            add_child(node, create_node("ERROR", "missing_rparen"));
        }
    } else {
        add_child(node, match(p, "D_RPAREN"));
    }
    
    // ERROR RECOVERY: Check for opening brace
    if (peek(p) && !check_token(p, "D_LBRACE")) {
        parser_error(p, "Missing '{' after condition");
        
        // Skip until we find a statement or closing brace
        // Parse the orphan statement but don't expect braces
        add_child(node, create_node("ERROR", "missing_lbrace"));
        
        // If the next token is a statement starter, parse ONE statement only
        if (peek(p) && (check_token(p, "K_ANI") || check_token(p, "K_TANIM") || 
                         check_token(p, "L_IDENTIFIER") || check_token(p, "R_BILANG"))) {
            add_child(node, parse_statement(p));
        }
        
        // If there's a closing brace, consume it
        if (peek(p) && check_token(p, "D_RBRACE")) {
            add_child(node, match(p, "D_RBRACE"));
        } else {
            add_child(node, create_node("ERROR", "missing_rbrace"));
        }
        
        add_child(node, parse_conditional_tail(p));
        printf("    [PDA POP] Conditional complete (with errors)\n");
        return node;
    }
    
    add_child(node, match(p, "D_LBRACE"));
    add_child(node, parse_statement_list(p));
    
    // ERROR RECOVERY: Check for closing brace
    if (peek(p) && !check_token(p, "D_RBRACE")) {
        parser_error(p, "Missing '}' at end of if block");
        const char* sync[] = {"D_RBRACE", "K_KUNDI", "K_KUNDIMAN"};
        synchronize(p, sync, 3);
        
        if (peek(p) && check_token(p, "D_RBRACE")) {
            add_child(node, match(p, "D_RBRACE"));
        } else {
            add_child(node, create_node("ERROR", "missing_rbrace"));
        }
    } else {
        add_child(node, match(p, "D_RBRACE"));
    }
    
    add_child(node, parse_conditional_tail(p));
    printf("    [PDA POP] Conditional complete\n");
    exit_nonterminal("Conditional", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_conditional_tail(Parser* p) {
    enter_nonterminal("ConditionalTail", p->current_token->lexeme);
    ParseTreeNode* node = create_node("ConditionalTail", NULL);
    if (peek(p) && check_token(p, "K_KUNDI")) {
        add_child(node, match(p, "K_KUNDI"));
        add_child(node, match(p, "D_LBRACE"));
        add_child(node, parse_statement_list(p));
        add_child(node, match(p, "D_RBRACE"));
    } else if (peek(p) && check_token(p, "K_KUNDIMAN")) {
        add_child(node, match(p, "K_KUNDIMAN"));
        add_child(node, match(p, "D_LPAREN"));
        add_child(node, parse_boolean_expression(p));
        add_child(node, match(p, "D_RPAREN"));
        add_child(node, match(p, "D_LBRACE"));
        add_child(node, parse_statement_list(p));
        add_child(node, match(p, "D_RBRACE"));
        add_child(node, parse_conditional_tail(p));
    } else {
        add_child(node, create_node("ε", "empty"));
    }
    exit_nonterminal("ConditionalTail", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_boolean_expression(Parser* p) {
    enter_nonterminal("BooleanExpression", p->current_token->lexeme);
    ParseTreeNode* node = create_node("BooleanExpression", NULL);
    add_child(node, parse_expression(p));
    add_child(node, parse_relop(p));
    add_child(node, parse_expression(p));
    exit_nonterminal("BooleanExpression", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_relop(Parser* p) {
    enter_nonterminal("RelOp", p->current_token->lexeme);
    ParseTreeNode* node = create_node("RelOp", NULL);
    if (peek(p) && (check_token(p, "O_EQUAL") || check_token(p, "O_NOT_EQUAL") ||
                     check_token(p, "O_GREATER") || check_token(p, "O_LESS") ||
                     check_token(p, "O_GREATER_EQ") || check_token(p, "O_LESS_EQ"))) {
        add_child(node, create_node(p->current_token->type, p->current_token->lexeme));
        advance(p);
    } else {
        parser_error(p, "Expected relational operator");
    }
    exit_nonterminal("RelOp", p->current_token->lexeme);
    return node;
}

// ============ ITERATIONS/LOOPS ============

ParseTreeNode* parse_iterative(Parser* p) {
    enter_nonterminal("Iterative", p->current_token->lexeme);
    ParseTreeNode* node = create_node("Iterative", NULL);
    if (check_token(p, "K_PARA")) {
        add_child(node, parse_for_loop(p));
    } else if (check_token(p, "K_HABANG")) {
        add_child(node, parse_while_loop(p));
    } else if (check_token(p, "K_GAWIN")) {
        add_child(node, parse_do_while_loop(p));
    }
    exit_nonterminal("Iterative", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_for_loop(Parser* p) {
    enter_nonterminal("ForLoop", p->current_token->lexeme);
    printf("    [PDA PUSH] Parsing For Loop...\n");
    ParseTreeNode* node = create_node("ForLoop", NULL);
    add_child(node, match(p, "K_PARA"));

    if (peek(p) && !check_token(p, "D_LPAREN")) {
        parser_error(p, "Missing '(' after 'para'");
        const char* sync[] = {"D_LPAREN"};
        synchronize(p, sync, 1);
    }

    add_child(node, match(p, "D_LPAREN"));
    
    // Parse initialization
    if (check_token(p, "R_BILANG") || check_token(p, "R_LUTANG") ||
        check_token(p, "R_BULYAN") || check_token(p, "R_KWERDAS")) {
        add_child(node, parse_declaration(p));
    } else if (peek(p) && check_token(p, "L_IDENTIFIER")) {
        ParseTreeNode* assign = create_node("Assignment", NULL);
        add_child(assign, match(p, "L_IDENTIFIER"));
        add_child(assign, match(p, "O_ASSIGN"));
        add_child(assign, parse_expression(p));
        add_child(assign, match(p, "D_SEMICOLON"));
        add_child(node, assign);
    } else {
        parser_error(p, "Expected initialization in for loop");
        add_child(node, create_node("ERROR", "missing_init"));
    }

    // Parse condition - Try to detect if semicolon is missing
    ParseTreeNode* condition = create_node("BooleanExpression", NULL);
    
    // Parse left side of condition
    if (peek(p) && check_token(p, "L_IDENTIFIER")) {
        add_child(condition, parse_expression(p));
        
        // Check for relational operator
        if (peek(p) && (check_token(p, "O_EQUAL") || check_token(p, "O_NOT_EQUAL") ||
                         check_token(p, "O_GREATER") || check_token(p, "O_LESS") ||
                         check_token(p, "O_GREATER_EQ") || check_token(p, "O_LESS_EQ"))) {
            add_child(condition, parse_relop(p));
            add_child(condition, parse_expression(p));
        } else {
            parser_error(p, "Expected relational operator in condition");
            add_child(condition, create_node("ERROR", "missing_relop"));
        }
    } else {
        parser_error(p, "Expected condition in for loop");
        add_child(condition, create_node("ERROR", "missing_condition"));
    }
    
    add_child(node, condition);
    
    // Check for semicolon after condition
    if (peek(p) && !check_token(p, "D_SEMICOLON")) {
        parser_error(p, "Missing ';' after for loop condition");
        
        // Try to detect if we're already at the increment part
        // If we see an identifier that looks like increment (not relop), we're missing semicolon
        if (peek(p) && check_token(p, "L_IDENTIFIER")) {
            printf("    [ERROR RECOVERY] Detected missing semicolon before increment\n");
            // Don't skip anything, just note the error and continue
            add_child(node, create_node("ERROR", "missing_semicolon"));
        } else {
            // Otherwise try to find semicolon
            const char* sync[] = {"D_SEMICOLON"};
            synchronize(p, sync, 1);
            if (peek(p) && check_token(p, "D_SEMICOLON")) {
                add_child(node, match(p, "D_SEMICOLON"));
            } else {
                add_child(node, create_node("ERROR", "missing_semicolon"));
            }
        }
    } else {
        add_child(node, match(p, "D_SEMICOLON"));
    }
    
    // Parse increment
    if (peek(p) && check_token(p, "L_IDENTIFIER")) {
        ParseTreeNode* incr = create_node("Assignment", NULL);
        add_child(incr, match(p, "L_IDENTIFIER"));
        
        if (peek(p) && check_token(p, "O_ASSIGN")) {
            add_child(incr, match(p, "O_ASSIGN"));
            add_child(incr, parse_expression(p));
        } else {
            parser_error(p, "Expected '=' in for loop increment");
            add_child(incr, create_node("ERROR", "missing_assign"));
        }
        add_child(node, incr);
    } else if (peek(p) && !check_token(p, "D_RPAREN")) {
        parser_error(p, "Expected increment expression in for loop");
        add_child(node, create_node("ERROR", "missing_increment"));
        // Skip to closing paren
        const char* sync[] = {"D_RPAREN"};
        synchronize(p, sync, 1);
    } else {
        // Empty increment is technically ok, just add placeholder
        add_child(node, create_node("EmptyIncrement", ""));
    }
    
    // Check for closing parenthesis
    if (peek(p) && !check_token(p, "D_RPAREN")) {
        parser_error(p, "Missing ')' in for loop header");
        const char* sync[] = {"D_RPAREN", "D_LBRACE"};
        synchronize(p, sync, 2);
    }
    
    if (peek(p) && check_token(p, "D_RPAREN")) {
        add_child(node, match(p, "D_RPAREN"));
    } else {
        add_child(node, create_node("ERROR", "missing_rparen"));
    }
    
    // Parse body
    if (peek(p) && !check_token(p, "D_LBRACE")) {
        parser_error(p, "Missing '{' for for loop body");
        const char* sync[] = {"D_LBRACE"};
        synchronize(p, sync, 1);
    }
    
    if (peek(p) && check_token(p, "D_LBRACE")) {
        add_child(node, match(p, "D_LBRACE"));
        add_child(node, parse_statement_list(p));
        
        if (peek(p) && !check_token(p, "D_RBRACE")) {
            parser_error(p, "Missing '}' at end of for loop");
            const char* sync[] = {"D_RBRACE"};
            synchronize(p, sync, 1);
        }
        
        if (peek(p) && check_token(p, "D_RBRACE")) {
            add_child(node, match(p, "D_RBRACE"));
        } else {
            add_child(node, create_node("ERROR", "missing_rbrace"));
        }
    }
    
    printf("    [PDA POP] For Loop complete\n");
    exit_nonterminal("ForLoop", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_while_loop(Parser* p) {
    enter_nonterminal("WhileLoop", p->current_token->lexeme);
    printf("    [PDA PUSH] Parsing While Loop...\n");
    ParseTreeNode* node = create_node("WhileLoop", NULL);
    add_child(node, match(p, "K_HABANG"));
    add_child(node, match(p, "D_LPAREN"));
    add_child(node, parse_boolean_expression(p));
    
    // ERROR RECOVERY: Check for closing parenthesis
    if (peek(p) && !check_token(p, "D_RPAREN")) {
        parser_error(p, "Missing ')' after while condition");
        const char* sync[] = {"D_RPAREN", "D_LBRACE"};
        synchronize(p, sync, 2);
    }
    
    add_child(node, match(p, "D_RPAREN"));
    
    // ERROR RECOVERY: Check for loop body
    if (peek(p) && !check_token(p, "D_LBRACE")) {
        parser_error(p, "Missing '{' for while loop body");
        const char* sync[] = {"D_LBRACE"};
        synchronize(p, sync, 1);
    }
    
    add_child(node, match(p, "D_LBRACE"));
    add_child(node, parse_statement_list(p));
    
    // ERROR RECOVERY: Check for closing brace
    if (peek(p) && !check_token(p, "D_RBRACE")) {
        parser_error(p, "Missing '}' at end of while loop");
        skip_to_closing_brace(p);
    }
    
    add_child(node, match(p, "D_RBRACE"));
    printf("    [PDA POP] While Loop complete\n");
    exit_nonterminal("WhileLoop", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_do_while_loop(Parser* p) {
    enter_nonterminal("DoWhileLoop", p->current_token->lexeme);
    printf("    [PDA PUSH] Parsing Do-While Loop...\n");
    ParseTreeNode* node = create_node("DoWhileLoop", NULL);
    add_child(node, match(p, "K_GAWIN"));
    
    // ERROR RECOVERY: Check for opening brace
    if (peek(p) && !check_token(p, "D_LBRACE")) {
        parser_error(p, "Missing '{' after 'gawin'");
        const char* sync[] = {"D_LBRACE"};
        synchronize(p, sync, 1);
    }
    
    add_child(node, match(p, "D_LBRACE"));
    add_child(node, parse_statement_list(p));
    
    // ERROR RECOVERY: Check for closing brace
    if (peek(p) && !check_token(p, "D_RBRACE")) {
        parser_error(p, "Missing '}' in do-while loop");
        const char* sync[] = {"D_RBRACE", "K_HABANG"};
        synchronize(p, sync, 2);
    }
    
    add_child(node, match(p, "D_RBRACE"));
    
    // ERROR RECOVERY: Check for 'habang' keyword
    if (peek(p) && !check_token(p, "K_HABANG")) {
        parser_error(p, "Expected 'habang' after do-while body");
        const char* sync[] = {"K_HABANG"};
        synchronize(p, sync, 1);
    }
    
    add_child(node, match(p, "K_HABANG"));
    add_child(node, match(p, "D_LPAREN"));
    add_child(node, parse_boolean_expression(p));
    
    // ERROR RECOVERY: Check for closing parenthesis
    if (peek(p) && !check_token(p, "D_RPAREN")) {
        parser_error(p, "Missing ')' in do-while condition");
        const char* sync[] = {"D_RPAREN", "D_SEMICOLON"};
        synchronize(p, sync, 2);
    }
    
    add_child(node, match(p, "D_RPAREN"));
    
    // ERROR RECOVERY: Check for semicolon - THIS IS THE MISSING PART
    if (peek(p) && !check_token(p, "D_SEMICOLON")) {
        parser_error(p, "Missing ';' at end of do-while statement");
        const char* sync[] = {"D_SEMICOLON"};
        synchronize(p, sync, 1);
        
        if (peek(p) && check_token(p, "D_SEMICOLON")) {
            add_child(node, match(p, "D_SEMICOLON"));
        } else {
            add_child(node, create_node("ERROR", "missing_semicolon"));
        }
    } else {
        add_child(node, match(p, "D_SEMICOLON"));
    }
    
    printf("    [PDA POP] Do-While Loop complete\n");
    exit_nonterminal("DoWhileLoop", p->current_token->lexeme);
    return node;
}

// ============ INPUT/OUTPUT ============

ParseTreeNode* parse_print(Parser* p) {
    enter_nonterminal("Print", p->current_token->lexeme);
    printf("    [PDA PUSH] Parsing Print...\n");
    ParseTreeNode* node = create_node("Print", NULL);
    add_child(node, match(p, "K_ANI"));
    
    // ERROR RECOVERY: Check for opening parenthesis
    if (peek(p) && !check_token(p, "D_LPAREN")) {
        parser_error(p, "Missing '(' after 'ani'");
        const char* sync[] = {"D_LPAREN"};
        synchronize(p, sync, 1);
    }
    
    add_child(node, match(p, "D_LPAREN"));
    add_child(node, parse_print_args(p));
    
    // ERROR RECOVERY: Check for closing parenthesis
    if (peek(p) && !check_token(p, "D_RPAREN")) {
        parser_error(p, "Missing ')' in print statement");
        const char* sync[] = {"D_RPAREN", "D_SEMICOLON"};
        synchronize(p, sync, 2);
        
        if (peek(p) && check_token(p, "D_RPAREN")) {
            add_child(node, match(p, "D_RPAREN"));
        } else {
            add_child(node, create_node("ERROR", "missing_rparen"));
        }
    } else {
        add_child(node, match(p, "D_RPAREN"));
    }
    
    // ERROR RECOVERY: Check for semicolon
    if (peek(p) && !check_token(p, "D_SEMICOLON")) {
        parser_error(p, "Missing ';' at end of print statement");
        const char* sync[] = {"D_SEMICOLON"};
        synchronize(p, sync, 1);
        
        if (peek(p) && check_token(p, "D_SEMICOLON")) {
            add_child(node, match(p, "D_SEMICOLON"));
        } else {
            add_child(node, create_node("ERROR", "missing_semicolon"));
        }
    } else {
        add_child(node, match(p, "D_SEMICOLON"));
    }
    
    printf("    [PDA POP] Print complete\n");
    exit_nonterminal("Print", p->current_token->lexeme);
    return node;
}


ParseTreeNode* parse_print_args(Parser* p) {
    enter_nonterminal("PrintArgs", p->current_token->lexeme);
    ParseTreeNode* node = create_node("PrintArgs", NULL);
    add_child(node, parse_expression(p));
    if (peek(p) && check_token(p, "D_COMMA")) {
        add_child(node, match(p, "D_COMMA"));
        add_child(node, parse_print_args(p));
    }
    exit_nonterminal("PrintArgs", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_scan(Parser* p) {
    enter_nonterminal("Scan", p->current_token->lexeme);
    printf("    [PDA PUSH] Parsing Scan...\n");
    ParseTreeNode* node = create_node("Scan", NULL);
    add_child(node, match(p, "K_TANIM"));
    
    // ERROR RECOVERY: Check for opening parenthesis
    if (peek(p) && !check_token(p, "D_LPAREN")) {
        parser_error(p, "Missing '(' after 'tanim'");
        const char* sync[] = {"D_LPAREN"};
        synchronize(p, sync, 1);
    }
    
    add_child(node, match(p, "D_LPAREN"));
    add_child(node, parse_scan_args(p));
    
    // ERROR RECOVERY: Check for closing parenthesis
    if (peek(p) && !check_token(p, "D_RPAREN")) {
        parser_error(p, "Missing ')' in scan statement");
        const char* sync[] = {"D_RPAREN", "D_SEMICOLON"};
        synchronize(p, sync, 2);
        
        if (peek(p) && check_token(p, "D_RPAREN")) {
            add_child(node, match(p, "D_RPAREN"));
        } else {
            add_child(node, create_node("ERROR", "missing_rparen"));
        }
    } else {
        add_child(node, match(p, "D_RPAREN"));
    }
    
    // ERROR RECOVERY: Check for semicolon
    if (peek(p) && !check_token(p, "D_SEMICOLON")) {
        parser_error(p, "Missing ';' at end of scan statement");
        const char* sync[] = {"D_SEMICOLON"};
        synchronize(p, sync, 1);
        
        if (peek(p) && check_token(p, "D_SEMICOLON")) {
            add_child(node, match(p, "D_SEMICOLON"));
        } else {
            add_child(node, create_node("ERROR", "missing_semicolon"));
        }
    } else {
        add_child(node, match(p, "D_SEMICOLON"));
    }
    
    printf("    [PDA POP] Scan complete\n");
    exit_nonterminal("Scan", p->current_token->lexeme);
    return node;
}

ParseTreeNode* parse_scan_args(Parser* p) {
    enter_nonterminal("ScanArgs", p->current_token->lexeme);
    ParseTreeNode* node = create_node("ScanArgs", NULL);
    add_child(node, match(p, "L_IDENTIFIER"));
    if (peek(p) && check_token(p, "D_COMMA")) {
        add_child(node, match(p, "D_COMMA"));
        add_child(node, parse_scan_args(p));
    }
    exit_nonterminal("ScanArgs", p->current_token->lexeme);
    return node;
}

// ============ CLASS DEFINITION ============

ParseTreeNode* parse_class_definition(Parser* p) {
    enter_nonterminal("ClassDefinition", p->current_token->lexeme);
    printf("  [PDA PUSH] Parsing Class Definition...\n");
    ParseTreeNode* node = create_node("ClassDefinition", NULL);
    add_child(node, match(p, "K_PANGKAT"));
    add_child(node, match(p, "L_IDENTIFIER"));
    add_child(node, match(p, "D_LBRACE"));
    add_child(node, match(p, "D_RBRACE"));
    printf("  [PDA POP] Class Definition complete\n");
    exit_nonterminal("ClassDefinition", p->current_token->lexeme);
    return node;
}

// ============ FILE I/O ============

Token* read_symbol_table(const char* filename, int* count) {
    FILE* fp = fopen(filename, "r");
    if (!fp) {
        printf("\nERROR: Cannot open file '%s'\n", filename);
        printf("Make sure 'Symbol Table.txt' exists in the same folder!\n");
        *count = 0;
        return NULL;
    }
    
    Token* tokens = (Token*)malloc(MAX_TOKENS * sizeof(Token));
    *count = 0;
    char line[512];
    
    printf("\nReading symbol table from '%s'...\n", filename);
    
    // Skip header line
    if (fgets(line, sizeof(line), fp)) {
        printf("Header: %s", line);
    }
    
    // Read tokens
    while (fgets(line, sizeof(line), fp) && *count < MAX_TOKENS) {
        // Parse format: lexeme | token | line
        char lexeme[MAX_TOKEN_LENGTH];
        char token_type[MAX_TOKEN_LENGTH];
        int line_num;
        
        char* lex_ptr = strtok(line, "|");
        char* token_ptr = strtok(NULL, "|");
        char* line_ptr = strtok(NULL, "|");
        
        if (lex_ptr && token_ptr && line_ptr) {
            strcpy(lexeme, lex_ptr);
            strcpy(token_type, token_ptr);
            line_num = atoi(line_ptr);
            
            // Trim whitespace
            trim(lexeme);
            trim(token_type);
            
            strcpy(tokens[*count].lexeme, lexeme);
            strcpy(tokens[*count].type, token_type);
            tokens[*count].line = line_num;
            (*count)++;
        }
    }
    
    fclose(fp);
    printf("Successfully read %d tokens from symbol table.\n\n", *count);
    return tokens;
}

void print_parse_tree_visual_helper(ParseTreeNode* node, FILE* fp, char* prefix, bool is_last) {
    if (!node) return;
    
    fprintf(fp, "%s", prefix);
    fprintf(fp, "%s", is_last ? "└── " : "├── ");
    fprintf(fp, "%s", node->name);
    if (strlen(node->value) > 0 && strcmp(node->value, "empty") != 0) {
        fprintf(fp, " [%s]", node->value);
    }
    fprintf(fp, "\n");
    
    char new_prefix[512];
    sprintf(new_prefix, "%s%s", prefix, is_last ? "    " : "│   ");
    
    for (int i = 0; i < node->child_count; i++) {
        print_parse_tree_visual_helper(node->children[i], fp, new_prefix, 
                                       i == node->child_count - 1);
    }
}

void print_parse_tree_parenthesized_helper(ParseTreeNode* node, FILE* fp, int indent) {
    if (!node) return;
    
    // Print indentation
    for (int j = 0; j < indent; j++) fprintf(fp, "  ");
    
    if (node->child_count == 0) {
        fprintf(fp, "%s", node->name);
        if (strlen(node->value) > 0 && strcmp(node->value, "empty") != 0) {
            fprintf(fp, "(%s)", node->value);
        }
        return;
    }
    
    fprintf(fp, "%s(\n", node->name);
    for (int i = 0; i < node->child_count; i++) {
        print_parse_tree_parenthesized_helper(node->children[i], fp, indent + 1);
        if (i < node->child_count - 1) {
            fprintf(fp, ",");
        }
        fprintf(fp, "\n");
    }
    
    // Closing parenthesis
    for (int j = 0; j < indent; j++) fprintf(fp, "  ");
    fprintf(fp, ")");
}

void write_parse_tree_to_file(const char* filename, ParseTreeNode* tree, bool is_visual) {
    FILE* fp = fopen(filename, "w");
    if (!fp) {
        printf("ERROR: Cannot create output file '%s'\n", filename);
        return;
    }
    
    fprintf(fp, "PARSE TREE (%s FORMAT)\n", is_visual ? "VISUAL" : "PARENTHESIZED");
    fprintf(fp, "Generated by Recursive Descent Parser (Pushdown Automaton)\n");
    fprintf(fp, "======================================================================\n\n");
    
    if (is_visual) {
        char prefix[512] = "";
        print_parse_tree_visual_helper(tree, fp, prefix, true);
    } else {
        print_parse_tree_parenthesized_helper(tree, fp, 0);
        fprintf(fp, "\n");
    }
    
    fprintf(fp, "\n======================================================================\n");
    fprintf(fp, "End of Parse Tree\n");
    
    fclose(fp);
    printf("Parse tree written to '%s'\n", filename);
}
